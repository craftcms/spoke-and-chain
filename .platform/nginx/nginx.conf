user                    nginx;
error_log               /var/log/nginx/error.log warn;
pid                     /var/run/nginx.pid;
worker_processes        auto;
worker_rlimit_nofile    200000;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    include       conf.d/*.conf;

    map $http_upgrade $connection_upgrade {
        default     "upgrade";
    }

    # Bots to ban via user agent
    map $http_user_agent $limit_bots {
         default 0;
         ~*(AhrefsBot|Baiduspider|PaperLiBot) 1;
    }

    # redirect http to https
    server {
        listen 80;
        listen [::]:80;
        server_name _;
        server_tokens off;
        return 301 https://$host$request_uri;
    }

    server {
        listen        80 default_server;
        access_log    /var/log/nginx/access.log main;
        charset utf-8;

        client_header_timeout 60;
        client_body_timeout   60;
        keepalive_timeout     60;

        # Disable limits on the maximum allowed size of the client request body
        client_max_body_size 0;

        # Compression

        # Enable Gzip compressed.
        gzip on;

        # Compression level (1-9).
        # 5 is a perfect compromise between size and cpu usage, offering about
        # 75% reduction for most ascii files (almost identical to level 9).
        gzip_comp_level    5;

        # Don't compress anything that's already small and unlikely to shrink much
        # if at all (the default is 20 bytes, which is bad as that usually leads to
        # larger files after gzipping).
        gzip_min_length    256;

        # Compress data even for clients that are connecting to us via proxies,
        # identified by the "Via" header (required for CloudFront).
        gzip_proxied       any;

        # Tell proxies to cache both the gzipped and regular version of a resource
        # whenever the client's Accept-Encoding capabilities header varies;
        # Avoids the issue where a non-gzip capable client (which is extremely rare
        # today) would display gibberish if their proxy gave them the gzipped version.
        gzip_vary          on;

        # Compress all output labeled with one of the following MIME-types.
        gzip_types
            application/atom+xml
            application/javascript
            application/json
            application/ld+json
            application/manifest+json
            application/rss+xml
            application/vnd.geo+json
            application/vnd.ms-fontobject
            application/x-font-ttf
            application/x-javascript
            application/x-web-app-manifest+json
            application/xhtml+xml
            application/xml
            application/xml+rss
            font/opentype
            image/bmp
            image/svg+xml
            image/x-icon
            text/cache-manifest
            text/css
            text/javascript
            text/plain
            text/vcard
            text/vnd.rim.location.xloc
            text/vtt
            text/x-component
            text/xml
            text/x-cross-domain-policy;
            # text/html is always compressed by HttpGzipModule

        # Ban certain bots from crawling the site
        if ($limit_bots = 1) {
            return 403;
        }

        # 404 error handler
        error_page 404 /index.php?$query_string;

        # 301 Redirect URLs with trailing /'s as per https://webmasters.googleblog.com/2010/04/to-slash-or-not-to-slash.html
        rewrite ^/(.*)/$ /$1 permanent;

        # Change // -> / for all URLs, so it works for our php location block, too
        merge_slashes off;
        rewrite (.*)//+(.*) $1/$2 permanent;

        # Don't send the nginx version number in error pages and Server header
        server_tokens off;

        # For WordPress bots/users
        location ~ ^/(wp-login|wp-admin|wp-config|wp-content|wp-includes|xmlrpc) {
            return 301 https://wordpress.com/wp-login.php;
        }

        # Handle Do Not Track as per https://www.eff.org/dnt-policy
        location /.well-known/dnt-policy.txt {
            try_files /dnt-policy.txt /index.php?p=/dnt-policy.txt;
        }

        # Security headers via https://securityheaders.io
        add_header Strict-Transport-Security "max-age=15768000; includeSubDomains; preload" always;
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header Referrer-Policy "no-referrer-when-downgrade" always;

        # Expire rules for static content

        # No default expire rule. This config mirrors that of apache as outlined in the
        # html5-boilerplate .htaccess file. However, nginx applies rules by location,
        # the apache rules are defined by type. A consequence of this difference is that
        # if you use no file extension in the url and serve html, with apache you get an
        # expire time of 0s, with nginx you'd get an expire header of one month in the
        # future (if the default expire rule is 1 month). Therefore, do not use a
        # default expire rule with nginx unless your site is completely static

        # Media: images, icons, video, audio, HTC
        location ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp3|mp4|ogg|ogv|webm|htc|webp)$ {
            # Uncomment these lines if you want to serve up a placeholder image for 404s
            # for static assets:
            # error_page 404 /img/placeholder-image.png;
            # try_files $uri =404;
            etag off;
            expires 1M;
            access_log off;
            # Route any 404s back through Craft
            try_files $uri /index.php?$query_string;
            # max-age=2592000 = 1 month in seconds, stale-while-revalidate=86400 = 1 day in seconds
            add_header Cache-Control "public, max-age=2592000, must-revalidate, stale-while-revalidate=86400";
        }

        # CSS and Javascript
        location ~* \.(?:css|js)$ {
            etag off;
            expires 1y;
            access_log off;
            # Route any 404s back through Craft
            try_files $uri /index.php?$query_string;
            # max-age=31556952 = 1 year in seconds
            add_header Cache-Control "public, max-age=31556952, immutable";
        }

        # WebFonts
        location ~* \.(?:ttf|ttc|otf|eot|woff|woff2)$ {
            etag off;
            add_header "Access-Control-Allow-Origin" "*";
            expires 1M;
            access_log off;
            # Route any 404s back through Craft
            try_files $uri /index.php?$query_string;
            # max-age=2592000 = 1 month in seconds, stale-while-revalidate=86400 = 1 day in seconds
            add_header Cache-Control "public, max-age=2592000, must-revalidate, stale-while-revalidate=86400";
         }

        # Root directory location handler
        location / {
            try_files $uri/index.html $uri $uri/ /index.php?$query_string;
        }

        # Craft-specific location handlers to ensure AdminCP requests route through index.php
        # If you change your `cpTrigger`, change it here as well
        location ^~ /admin {
            try_files $uri $uri/ /index.php?$query_string;
        }
        location ^~ /cpresources {
            try_files $uri $uri/ /index.php?$query_string;
        }

        # Disable reading of Apache .htaccess files
        location ~ /\.ht {
            deny all;
        }

        # Misc settings
        sendfile off;

        # Include the Elastic Beanstalk generated locations
        include conf.d/elasticbeanstalk/*.conf;
    }
}